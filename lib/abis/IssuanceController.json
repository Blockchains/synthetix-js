{
  "contractName": "IssuanceController",
  "abi": [
    {
      "constant": false,
      "inputs": [
        {
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "nominateNewOwner",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "_paused",
          "type": "bool"
        }
      ],
      "name": "setPaused",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "initiationTime",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "_beneficiary",
          "type": "address"
        }
      ],
      "name": "setSelfDestructBeneficiary",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "terminateSelfDestruct",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "nominatedOwner",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "lastPauseTime",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "selfDestruct",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "SELFDESTRUCT_DELAY",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "selfDestructInitiated",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [],
      "name": "initiateSelfDestruct",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "selfDestructBeneficiary",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "isPaused",
          "type": "bool"
        }
      ],
      "name": "PauseChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "SelfDestructTerminated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "beneficiary",
          "type": "address"
        }
      ],
      "name": "SelfDestructed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "selfDestructDelay",
          "type": "uint256"
        }
      ],
      "name": "SelfDestructInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "newBeneficiary",
          "type": "address"
        }
      ],
      "name": "SelfDestructBeneficiaryUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerNominated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerChanged",
      "type": "event"
    }
  ],
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "sourceMap": "",
  "deployedSourceMap": "",
  "source": "// /*\n// -----------------------------------------------------------------\n// FILE INFORMATION\n// -----------------------------------------------------------------\n\n// file:       IssuanceController.sol\n// version:    2.0\n// author:     Kevin Brown\n// date:       2018-07-18\n\n// -----------------------------------------------------------------\n// MODULE DESCRIPTION\n// -----------------------------------------------------------------\n\n// Issuance controller contract. The issuance controller provides\n// a way for users to acquire nomins (Nomin.sol) and havvens\n// (Havven.sol) by paying ETH and a way for users to acquire havvens\n// (Havven.sol) by paying nomins. Users can also deposit their nomins\n// and allow other users to purchase them with ETH. The ETH is sent\n// to the user who offered their nomins for sale.\n\n// This smart contract contains a balance of each currency, and\n// allows the owner of the contract (the Havven Foundation) to\n// manage the available balance of havven at their discretion, while\n// users are allowed to deposit and withdraw their own nomin deposits\n// if they have not yet been taken up by another user.\n\n// -----------------------------------------------------------------\n// */\n\npragma solidity 0.4.25;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./Pausable.sol\";\nimport \"./SelfDestructible.sol\";\n// import \"./Havven.sol\";\n// import \"./Nomin.sol\";\n\n/**\n * @title Issuance Controller Contract.\n */\ncontract IssuanceController is SelfDestructible, Pausable {\n    using SafeMath for uint;\n\n    /* ========== STATE VARIABLES ========== */\n//     Havven public havven;\n//     Nomin public nomin;\n\n//     // Address where the ether and Nomins raised for selling HAV is transfered to\n//     // Any ether raised for selling Nomins gets sent back to whoever deposited the Nomins,\n//     // and doesn't have anything to do with this address.\n//     address public fundsWallet;\n\n//     /* The address of the oracle which pushes the USD price havvens and ether to this contract */\n//     address public oracle;\n//     /* Do not allow the oracle to submit times any further forward into the future than\n//        this constant. */\n//     uint constant ORACLE_FUTURE_LIMIT = 10 minutes;\n\n//     /* How long will the contract assume the price of any asset is correct */\n//     uint public priceStalePeriod = 3 hours;\n\n//     /* The time the prices were last updated */\n//     uint public lastPriceUpdateTime;\n//     /* The USD price of havvens denominated in UNIT */\n//     uint public usdToHavPrice;\n//     /* The USD price of ETH denominated in UNIT */\n//     uint public usdToEthPrice;\n    \n//     /* Stores deposits from users. */\n//     struct nominDeposit {\n//         // The user that made the deposit\n//         address user;\n//         // The amount (in Nomins) that they deposited\n//         uint amount;\n//     }\n\n//     /* User deposits are sold on a FIFO (First in First out) basis. When users deposit\n//        nomins with us, they get added this queue, which then gets fulfilled in order.\n//        Conceptually this fits well in an array, but then when users fill an order we\n//        end up copying the whole array around, so better to use an index mapping instead\n//        for gas performance reasons.\n       \n//        The indexes are specified (inclusive, exclusive), so (0, 0) means there's nothing\n//        in the array, and (3, 6) means there are 3 elements at 3, 4, and 5. You can obtain\n//        the length of the \"array\" by querying depositEndIndex - depositStartIndex. All index\n//        operations use safeAdd, so there is no way to overflow, so that means there is a\n//        very large but finite amount of deposits this contract can handle before it fills up. */\n//     mapping(uint => nominDeposit) public deposits;\n//     // The starting index of our queue inclusive\n//     uint public depositStartIndex;\n//     // The ending index of our queue exclusive\n//     uint public depositEndIndex;\n\n//     /* This is a convenience variable so users and dApps can just query how much nUSD\n//        we have available for purchase without having to iterate the mapping with a\n//        O(n) amount of calls for something we'll probably want to display quite regularly. */\n//     uint public totalSellableDeposits;\n\n//     /* ========== CONSTRUCTOR ========== */\n\n//     /**\n//      * @dev Constructor\n//      * @param _owner The owner of this contract.\n//      * @param _fundsWallet The recipient of ETH and Nomins that are sent to this contract while exchanging.\n//      * @param _havven The Havven contract we'll interact with for balances and sending.\n//      * @param _nomin The Nomin contract we'll interact with for balances and sending.\n//      * @param _oracle The address which is able to update price information.\n//      * @param _usdToEthPrice The current price of ETH in USD, expressed in UNIT.\n//      * @param _usdToHavPrice The current price of Havven in USD, expressed in UNIT.\n//      */\n//     constructor(\n//         // Ownable\n//         address _owner,\n\n//         // Funds Wallet\n//         address _fundsWallet,\n\n//         // Other contracts needed\n//         Havven _havven,\n//         Nomin _nomin,\n\n//         // Oracle values - Allows for price updates\n//         address _oracle,\n//         uint _usdToEthPrice,\n//         uint _usdToHavPrice\n//     )\n//         /* Owned is initialised in SelfDestructible */\n//         SelfDestructible(_owner)\n//         Pausable(_owner)\n//         public\n//     {\n//         fundsWallet = _fundsWallet;\n//         havven = _havven;\n//         nomin = _nomin;\n//         oracle = _oracle;\n//         usdToEthPrice = _usdToEthPrice;\n//         usdToHavPrice = _usdToHavPrice;\n//         lastPriceUpdateTime = now;\n//         totalSellableDeposits = 0;\n//     }\n\n//     /* ========== SETTERS ========== */\n\n//     /**\n//      * @notice Set the funds wallet where ETH raised is held\n//      * @param _fundsWallet The new address to forward ETH and Nomins to\n//      */\n//     function setFundsWallet(address _fundsWallet)\n//         external\n//         onlyOwner\n//     {\n//         fundsWallet = _fundsWallet;\n//         emit FundsWalletUpdated(fundsWallet);\n//     }\n    \n//     /**\n//      * @notice Set the Oracle that pushes the havven price to this contract\n//      * @param _oracle The new oracle address\n//      */\n//     function setOracle(address _oracle)\n//         external\n//         onlyOwner\n//     {\n//         oracle = _oracle;\n//         emit OracleUpdated(oracle);\n//     }\n\n//     /**\n//      * @notice Set the Nomin contract that the issuance controller uses to issue Nomins.\n//      * @param _nomin The new nomin contract target\n//      */\n//     function setNomin(Nomin _nomin)\n//         external\n//         onlyOwner\n//     {\n//         nomin = _nomin;\n//         emit NominUpdated(_nomin);\n//     }\n\n//     /**\n//      * @notice Set the Havven contract that the issuance controller uses to issue Havvens.\n//      * @param _havven The new havven contract target\n//      */\n//     function setHavven(Havven _havven)\n//         external\n//         onlyOwner\n//     {\n//         havven = _havven;\n//         emit HavvenUpdated(_havven);\n//     }\n\n//     /**\n//      * @notice Set the stale period on the updated price variables\n//      * @param _time The new priceStalePeriod\n//      */\n//     function setPriceStalePeriod(uint _time)\n//         external\n//         onlyOwner \n//     {\n//         priceStalePeriod = _time;\n//         emit PriceStalePeriodUpdated(priceStalePeriod);\n//     }\n\n//     /* ========== MUTATIVE FUNCTIONS ========== */\n//     /**\n//      * @notice Access point for the oracle to update the prices of havvens / eth.\n//      * @param newEthPrice The current price of ether in USD, specified to 18 decimal places.\n//      * @param newHavvenPrice The current price of havvens in USD, specified to 18 decimal places.\n//      * @param timeSent The timestamp from the oracle when the transaction was created. This ensures we don't consider stale prices as current in times of heavy network congestion.\n//      */\n//     function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent)\n//         external\n//         onlyOracle\n//     {\n//         /* Must be the most recently sent price, but not too far in the future.\n//          * (so we can't lock ourselves out of updating the oracle for longer than this) */\n//         require(lastPriceUpdateTime < timeSent, \"Time must be later than last update\");\n//         require(timeSent < (now + ORACLE_FUTURE_LIMIT), \"Time must be less than now + ORACLE_FUTURE_LIMIT\");\n\n//         usdToEthPrice = newEthPrice;\n//         usdToHavPrice = newHavvenPrice;\n//         lastPriceUpdateTime = timeSent;\n\n//         emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);\n//     }\n\n//     /**\n//      * @notice Fallback function (exchanges ETH to nUSD)\n//      */\n//     function ()\n//         external\n//         payable\n//     {\n//         exchangeEtherForNomins();\n//     } \n\n//     event Log(string message);\n//     event LogInt(string message, uint number);\n//     event LogAddress(string message, address addr);\n\n//     /**\n//      * @notice Exchange ETH to nUSD.\n//      */\n//     function exchangeEtherForNomins()\n//         public \n//         payable\n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Nomins (nUSD) received\n//     {\n//         // The multiplication works here because usdToEthPrice is specified in\n//         // 18 decimal places, just like our currency base.\n//         uint requestedToPurchase = multiplyDecimal(msg.value, usdToEthPrice);\n//         emit LogInt(\"Requested to purchase\", requestedToPurchase);\n//         uint remainingToFulfill = requestedToPurchase;\n//         emit LogInt(\"Remaining to fulfill\", remainingToFulfill);\n\n//         // Iterate through our outstanding deposits and sell them one at a time.\n//         for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n//             nominDeposit memory deposit = deposits[i];\n\n//             emit LogAddress(\"Deposit address\", deposit.user);\n//             emit LogInt(\"Deposit amount\", deposit.amount);\n\n//             // If it's an empty spot in the queue from a previous withdrawal, just skip over it and\n//             // update the queue. It's already been deleted.\n//             if (deposit.user == address(0)) {\n//                 emit LogInt(\"Queue spot is already deleted, skipping\", i);\n\n//                 depositStartIndex = safeAdd(depositStartIndex, 1);\n//                 emit LogInt(\"New start index\", depositStartIndex);\n//             } else {\n//                 // If the deposit can more than fill the order, we can do this\n//                 // without touching the structure of our queue.\n//                 if (deposit.amount > remainingToFulfill) {\n//                     emit Log(\"Fulfilling from first deposit\");\n\n//                     // Ok, this deposit can fulfill the whole remainder. We don't need\n//                     // to change anything about our queue we can just fulfill it.\n//                     // Subtract the amount from our deposit and total.\n//                     deposit.amount = safeSub(deposit.amount, remainingToFulfill);\n//                     totalSellableDeposits = safeSub(totalSellableDeposits, remainingToFulfill);\n\n//                     emit LogInt(\"New deposit amount\", deposit.amount);\n//                     emit LogInt(\"New total sellable\", totalSellableDeposits);\n                    \n//                     // Transfer the ETH to the depositor.\n//                     deposit.user.transfer(divideDecimal(remainingToFulfill, usdToEthPrice));\n//                     emit LogInt(\"Transferring ETH\", divideDecimal(remainingToFulfill, usdToEthPrice));\n//                     // And the Nomins to the recipient.\n//                     // Note: Fees are calculated by the Nomin contract, so when \n//                     //       we request a specific transfer here, the fee is\n//                     //       automatically deducted and sent to the fee pool.\n//                     nomin.transfer(msg.sender, remainingToFulfill);\n//                     emit LogInt(\"Amount of Nomins transferred\", remainingToFulfill);\n\n//                     // And we have nothing left to fulfill on this order.\n//                     remainingToFulfill = 0;\n//                 } else if (deposit.amount <= remainingToFulfill) {\n//                     emit LogInt(\"Deposit amount\", deposit.amount);\n//                     emit LogInt(\"Remaining to fulfill\", remainingToFulfill);\n//                     emit Log(\"Amount exceeds first deposit, consuming\");\n//                     // We need to fulfill this one in its entirety and kick it out of the queue.\n//                     // Start by kicking it out of the queue.\n//                     // Free the storage because we can.\n//                     delete deposits[i];\n//                     // Bump our start index forward one.\n//                     depositStartIndex = safeAdd(depositStartIndex, 1);\n//                     // We also need to tell our total it's decreased\n//                     totalSellableDeposits = safeSub(totalSellableDeposits, deposit.amount);\n//                     emit LogInt(\"New start index\", depositStartIndex);\n//                     emit LogInt(\"New end index\", depositStartIndex);\n//                     emit LogInt(\"New queue length\", depositEndIndex - depositStartIndex);\n//                     emit LogInt(\"New total\", totalSellableDeposits);\n\n//                     // Now fulfill by transfering the ETH to the depositor.\n//                     deposit.user.transfer(divideDecimal(deposit.amount, usdToEthPrice));\n//                     emit LogInt(\"Transferring ETH\", divideDecimal(deposit.amount, usdToEthPrice));\n//                     // And the Nomins to the recipient.\n//                     // Note: Fees are calculated by the Nomin contract, so when \n//                     //       we request a specific transfer here, the fee is\n//                     //       automatically deducted and sent to the fee pool.\n//                     nomin.transfer(msg.sender, deposit.amount);\n//                     emit LogInt(\"Transferring Nomins\", deposit.amount);\n\n//                     // And subtract the order from our outstanding amount remaining\n//                     // for the next iteration of the loop.\n//                     remainingToFulfill = safeSub(remainingToFulfill, deposit.amount);\n//                     emit LogInt(\"New remaining to fulfill\", remainingToFulfill);\n//                 }\n//             }\n//         }\n\n//         // Ok, if we're here and 'remainingToFulfill' isn't zero, then\n//         // we need to refund the remainder of their ETH back to them.\n//         if (remainingToFulfill > 0) {\n//             msg.sender.transfer(divideDecimal(remainingToFulfill, usdToEthPrice));\n//         }\n\n//         // How many did we actually give them?\n//         uint fulfilled = safeSub(requestedToPurchase, remainingToFulfill);\n\n//         // Now tell everyone that we gave them that many.\n//         emit Exchange(\"ETH\", msg.value, \"nUSD\", fulfilled);\n\n//         return fulfilled;\n//     }\n\n//     /**\n//      * @notice Exchange ETH to nUSD while insisting on a particular rate. This allows a user to\n//      *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\n//      * @param guaranteedRate The exchange rate (ether price) which must be honored or the call will revert.\n//      */\n//     function exchangeEtherForNominsAtRate(uint guaranteedRate)\n//         public\n//         payable\n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Nomins (nUSD) received\n//     {\n//         require(guaranteedRate == usdToEthPrice, \"Guaranteed rate was not matched\");\n\n//         return exchangeEtherForNomins();\n//     }\n\n\n//     /**\n//      * @notice Exchange ETH to HAV.\n//      */\n//     function exchangeEtherForHavvens()\n//         public \n//         payable\n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Havvens (HAV) received\n//     {\n//         // How many Havvens are they going to be receiving?\n//         uint havvensToSend = havvensReceivedForEther(msg.value);\n\n//         // Store the ETH in our funds wallet\n//         fundsWallet.transfer(msg.value);\n\n//         // And send them the Havvens.\n//         havven.transfer(msg.sender, havvensToSend);\n\n//         emit Exchange(\"ETH\", msg.value, \"HAV\", havvensToSend);\n\n//         return havvensToSend;\n//     }\n\n//     /**\n//      * @notice Exchange ETH to HAV while insisting on a particular set of rates. This allows a user to\n//      *         exchange while protecting against frontrunning by the contract owner on the exchange rates.\n//      * @param guaranteedEtherRate The ether exchange rate which must be honored or the call will revert.\n//      * @param guaranteedHavvenRate The havven exchange rate which must be honored or the call will revert.\n//      */\n//     function exchangeEtherForHavvensAtRate(uint guaranteedEtherRate, uint guaranteedHavvenRate)\n//         public\n//         payable\n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Havvens (HAV) received\n//     {\n//         require(guaranteedEtherRate == usdToEthPrice, \"Guaranteed Ether rate was not matched\");\n//         require(guaranteedHavvenRate == usdToHavPrice, \"Guaranteed Havven rate was not matched\");\n\n//         return exchangeEtherForHavvens();\n//     }\n\n\n//     /**\n//      * @notice Exchange nUSD for Havvens\n//      * @param nominAmount The amount of nomins the user wishes to exchange.\n//      */\n//     function exchangeNominsForHavvens(uint nominAmount)\n//         public \n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Havvens (HAV) received\n//     {\n//         // How many Havvens are they going to be receiving?\n//         uint havvensToSend = havvensReceivedForNomins(nominAmount);\n        \n//         // Ok, transfer the Nomins to our funds wallet.\n//         // These do not go in the deposit queue as they aren't for sale as such unless\n//         // they're sent back in from the funds wallet.\n//         nomin.transferFrom(msg.sender, fundsWallet, nominAmount);\n\n//         // And send them the Havvens.\n//         havven.transfer(msg.sender, havvensToSend);\n\n//         emit Exchange(\"nUSD\", nominAmount, \"HAV\", havvensToSend);\n\n//         return havvensToSend; \n//     }\n\n//     /**\n//      * @notice Exchange nUSD for Havvens while insisting on a particular rate. This allows a user to\n//      *         exchange while protecting against frontrunning by the contract owner on the exchange rate.\n//      * @param nominAmount The amount of nomins the user wishes to exchange.\n//      * @param guaranteedRate A rate (havven price) the caller wishes to insist upon.\n//      */\n//     function exchangeNominsForHavvensAtRate(uint nominAmount, uint guaranteedRate)\n//         public \n//         pricesNotStale\n//         notPaused\n//         returns (uint) // Returns the number of Havvens (HAV) received\n//     {\n//         require(guaranteedRate == usdToHavPrice, \"Guaranteed rate was not matched\");\n\n//         return exchangeNominsForHavvens(nominAmount);\n//     }\n    \n//     /**\n//      * @notice Allows the owner to withdraw havvens from this contract if needed.\n//      * @param amount The amount of havvens to attempt to withdraw (in 18 decimal places).\n//      */\n//     function withdrawHavvens(uint amount)\n//         external\n//         onlyOwner\n//     {\n//         havven.transfer(owner, amount);\n        \n//         // We don't emit our own events here because we assume that anyone\n//         // who wants to watch what the Issuance Controller is doing can\n//         // just watch ERC20 events from the Nomin and/or Havven contracts\n//         // filtered to our address.\n//     }\n\n//     /**\n//      * @notice Allows a user to withdraw all of their previously deposited nomins from this contract if needed.\n//      *         Developer note: We could keep an index of address to deposits to make this operation more efficient\n//      *         but then all the other operations on the queue become less efficient. It's expected that this\n//      *         function will be very rarely used, so placing the inefficiency here is intentional. The usual\n//      *         use case does not involve a withdrawal.\n//      */\n//     function withdrawMyDepositedNomins()\n//         external\n//     {\n//         uint nominsToSend = 0;\n\n//         for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n//             nominDeposit memory deposit = deposits[i];\n\n//             if (deposit.user == msg.sender) {\n//                 // The user is withdrawing this deposit. Remove it from our queue.\n//                 // We'll just leave a gap, which the purchasing logic can walk past.\n//                 nominsToSend = safeAdd(nominsToSend, deposit.amount);\n//                 delete deposits[i];\n//             }\n//         }\n\n//         // If there's nothing to do then go ahead and revert the transaction\n//         require(nominsToSend > 0, \"You have no deposits to withdraw.\");\n\n//         // Update our total\n//         totalSellableDeposits = safeSub(totalSellableDeposits, nominsToSend);\n\n//         // Send their deposits back to them (minus fees)\n//         nomin.transfer(msg.sender, nominsToSend);\n        \n//         emit NominWithdrawal(msg.sender, nominsToSend);\n//     }\n\n//     /**\n//      * @notice depositNomins: Allows users to deposit nomins via the approve / transferFrom workflow\n//      *         if they'd like. You can equally just transfer nomins to this contract and it will work\n//      *         exactly the same way but with one less call (and therefore cheaper transaction fees)\n//      * @param amount The amount of nUSD you wish to deposit (must have been approved first)\n//      */\n//     function depositNomins(uint amount)\n//         external\n//     {\n//         // Grab the amount of nomins\n//         nomin.transferFrom(msg.sender, this, amount);\n\n//         // Note, we don't need to add them to the deposit list below, as the Nomin contract itself will\n//         // call tokenFallback when the transfer happens, adding their deposit to the queue.\n//     }\n\n//     /**\n//      * @notice Triggers when users send us HAV or nUSD, but the modifier only allows nUSD calls to proceed.\n//      * @param from The address sending the nUSD\n//      * @param amount The amount of nUSD\n//      */\n//     function tokenFallback(address from, uint amount, bytes data)\n//         external\n//         onlyNomin\n//     {\n//         // Ok, thanks for the deposit, let's queue it up.\n//         deposits[depositEndIndex] = nominDeposit({ user: from, amount: amount });\n//         // Walk our index forward as well.\n//         depositEndIndex = safeAdd(depositEndIndex, 1);\n\n//         // And add it to our total.\n//         totalSellableDeposits = safeAdd(totalSellableDeposits, amount);\n//     }\n\n//     /* ========== VIEWS ========== */\n//     /**\n//      * @notice Check if the prices haven't been updated for longer than the stale period.\n//      */\n//     function pricesAreStale()\n//         public\n//         view\n//         returns (bool)\n//     {\n//         return safeAdd(lastPriceUpdateTime, priceStalePeriod) < now;\n//     }\n\n//     /**\n//      * @notice Calculate how many havvens you will receive if you transfer\n//      *         an amount of nomins.\n//      * @param amount The amount of nomins (in 18 decimal places) you want to ask about\n//      */\n//     function havvensReceivedForNomins(uint amount)\n//         public \n//         view\n//         returns (uint)\n//     {\n//         // How many nomins would we receive after the transfer fee?\n//         uint nominsReceived = nomin.amountReceived(amount);\n\n//         // And what would that be worth in havvens based on the current price?\n//         return divideDecimal(nominsReceived, usdToHavPrice);\n//     }\n\n//     /**\n//      * @notice Calculate how many havvens you will receive if you transfer\n//      *         an amount of ether.\n//      * @param amount The amount of ether (in wei) you want to ask about\n//      */\n//     function havvensReceivedForEther(uint amount)\n//         public \n//         view\n//         returns (uint)\n//     {\n//         // How much is the ETH they sent us worth in nUSD (ignoring the transfer fee)?\n//         uint valueSentInNomins = multiplyDecimal(amount, usdToEthPrice); \n\n//         // Now, how many HAV will that USD amount buy?\n//         return havvensReceivedForNomins(valueSentInNomins);\n//     }\n\n//     /**\n//      * @notice Calculate how many nomins you will receive if you transfer\n//      *         an amount of ether.\n//      * @param amount The amount of ether (in wei) you want to ask about\n//      */\n//     function nominsReceivedForEther(uint amount)\n//         public \n//         view\n//         returns (uint)\n//     {\n//         // How many nomins would that amount of ether be worth?\n//         uint nominsTransferred = multiplyDecimal(amount, usdToEthPrice);\n\n//         // And how many of those would you receive after a transfer (deducting the transfer fee)\n//         return nomin.amountReceived(nominsTransferred);\n//     }\n    \n//     /* ========== MODIFIERS ========== */\n\n//     modifier onlyOracle\n//     {\n//         require(msg.sender == oracle, \"Only the oracle can perform this action\");\n//         _;\n//     }\n\n//     modifier onlyNomin\n//     {\n//         // We're only interested in doing anything on receiving nUSD.\n//         require(msg.sender == address(nomin), \"Only the nomin contract can perform this action\");\n//         _;\n//     }\n\n//     modifier pricesNotStale\n//     {\n//         require(!pricesAreStale(), \"Prices must not be stale to perform this action\");\n//         _;\n//     }\n\n//     /* ========== EVENTS ========== */\n\n//     event FundsWalletUpdated(address newFundsWallet);\n//     event OracleUpdated(address newOracle);\n//     event NominUpdated(Nomin newNominContract);\n//     event HavvenUpdated(Havven newHavvenContract);\n//     event PriceStalePeriodUpdated(uint priceStalePeriod);\n//     event PricesUpdated(uint newEthPrice, uint newHavvenPrice, uint timeSent);\n//     event Exchange(string fromCurrency, uint fromAmount, string toCurrency, uint toAmount);\n//     event NominWithdrawal(address user, uint amount);\n}\n",
  "sourcePath": "/Users/clintonennis/Projects/havven/havven/contracts/IssuanceController.sol",
  "ast": {
    "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/IssuanceController.sol",
    "exportedSymbols": {
      "IssuanceController": [
        4855
      ]
    },
    "id": 4856,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 4844,
        "literals": [
          "solidity",
          "0.4",
          ".25"
        ],
        "nodeType": "PragmaDirective",
        "src": "1220:23:6"
      },
      {
        "absolutePath": "openzeppelin-solidity/contracts/math/SafeMath.sol",
        "file": "openzeppelin-solidity/contracts/math/SafeMath.sol",
        "id": 4845,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 7093,
        "src": "1245:59:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/Pausable.sol",
        "file": "./Pausable.sol",
        "id": 4846,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 5983,
        "src": "1305:24:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/SelfDestructible.sol",
        "file": "./SelfDestructible.sol",
        "id": 4847,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 6660,
        "src": "1330:32:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 4848,
              "name": "SelfDestructible",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 6659,
              "src": "1494:16:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_SelfDestructible_$6659",
                "typeString": "contract SelfDestructible"
              }
            },
            "id": 4849,
            "nodeType": "InheritanceSpecifier",
            "src": "1494:16:6"
          },
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 4850,
              "name": "Pausable",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 5982,
              "src": "1512:8:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_Pausable_$5982",
                "typeString": "contract Pausable"
              }
            },
            "id": 4851,
            "nodeType": "InheritanceSpecifier",
            "src": "1512:8:6"
          }
        ],
        "contractDependencies": [
          5920,
          5982,
          6659
        ],
        "contractKind": "contract",
        "documentation": "@title Issuance Controller Contract.",
        "fullyImplemented": false,
        "id": 4855,
        "linearizedBaseContracts": [
          4855,
          5982,
          6659,
          5920
        ],
        "name": "IssuanceController",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "id": 4854,
            "libraryName": {
              "contractScope": null,
              "id": 4852,
              "name": "SafeMath",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 7092,
              "src": "1533:8:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_SafeMath_$7092",
                "typeString": "library SafeMath"
              }
            },
            "nodeType": "UsingForDirective",
            "src": "1527:24:6",
            "typeName": {
              "id": 4853,
              "name": "uint",
              "nodeType": "ElementaryTypeName",
              "src": "1546:4:6",
              "typeDescriptions": {
                "typeIdentifier": "t_uint256",
                "typeString": "uint256"
              }
            }
          }
        ],
        "scope": 4856,
        "src": "1463:25153:6"
      }
    ],
    "src": "1220:25397:6"
  },
  "legacyAST": {
    "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/IssuanceController.sol",
    "exportedSymbols": {
      "IssuanceController": [
        4855
      ]
    },
    "id": 4856,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 4844,
        "literals": [
          "solidity",
          "0.4",
          ".25"
        ],
        "nodeType": "PragmaDirective",
        "src": "1220:23:6"
      },
      {
        "absolutePath": "openzeppelin-solidity/contracts/math/SafeMath.sol",
        "file": "openzeppelin-solidity/contracts/math/SafeMath.sol",
        "id": 4845,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 7093,
        "src": "1245:59:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/Pausable.sol",
        "file": "./Pausable.sol",
        "id": 4846,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 5983,
        "src": "1305:24:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/Users/clintonennis/Projects/havven/havven/contracts/SelfDestructible.sol",
        "file": "./SelfDestructible.sol",
        "id": 4847,
        "nodeType": "ImportDirective",
        "scope": 4856,
        "sourceUnit": 6660,
        "src": "1330:32:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 4848,
              "name": "SelfDestructible",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 6659,
              "src": "1494:16:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_SelfDestructible_$6659",
                "typeString": "contract SelfDestructible"
              }
            },
            "id": 4849,
            "nodeType": "InheritanceSpecifier",
            "src": "1494:16:6"
          },
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 4850,
              "name": "Pausable",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 5982,
              "src": "1512:8:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_Pausable_$5982",
                "typeString": "contract Pausable"
              }
            },
            "id": 4851,
            "nodeType": "InheritanceSpecifier",
            "src": "1512:8:6"
          }
        ],
        "contractDependencies": [
          5920,
          5982,
          6659
        ],
        "contractKind": "contract",
        "documentation": "@title Issuance Controller Contract.",
        "fullyImplemented": false,
        "id": 4855,
        "linearizedBaseContracts": [
          4855,
          5982,
          6659,
          5920
        ],
        "name": "IssuanceController",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "id": 4854,
            "libraryName": {
              "contractScope": null,
              "id": 4852,
              "name": "SafeMath",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 7092,
              "src": "1533:8:6",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_SafeMath_$7092",
                "typeString": "library SafeMath"
              }
            },
            "nodeType": "UsingForDirective",
            "src": "1527:24:6",
            "typeName": {
              "id": 4853,
              "name": "uint",
              "nodeType": "ElementaryTypeName",
              "src": "1546:4:6",
              "typeDescriptions": {
                "typeIdentifier": "t_uint256",
                "typeString": "uint256"
              }
            }
          }
        ],
        "scope": 4856,
        "src": "1463:25153:6"
      }
    ],
    "src": "1220:25397:6"
  },
  "compiler": {
    "name": "solc",
    "version": "0.4.25+commit.59dbf8f1.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.0-beta.1",
  "updatedAt": "2018-11-21T03:50:47.552Z"
}